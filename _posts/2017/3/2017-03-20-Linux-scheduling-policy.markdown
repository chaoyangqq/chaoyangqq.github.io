---
layout:     post
random-img: true
title:      Linux 中的调度策略
subtitle:   The Scheduling Policy in Linux
date:       2017-03-20 11:14:12
author:     decaywood
description: 本文介绍了几种Linux中的进程调度策略
keywords: Linux,SCHED_OTHER,SCHED_FIFO,SCHED_RR,分时调度,实时调度
tags:
    - Linux
---

##linux内核的三种主要调度策略：

* SCHED\_OTHER **分时调度**策略
* SCHED\_FIFO **实时调度**策略，先到先服务
* SCHED\_RR **实时调度**策略，时间片轮转
  
实时进程将得到优先调用，实时进程根据实时优先级决定调度权值。分时进程则通过nice和counter值决定权值，nice越小，counter越大，被调度的概率越大，也就是曾经使用了cpu最少的进程将会得到优先调度。
 
## SHCED\_RR 和 SCHED\_FIFO 的异同：

### 不同点

当采用SHCED\_RR策略的进程的时间片用完，系统将重新分配时间片，并置于就绪队列尾。放在队列尾保证了所有具有相同优先级的RR任务的调度公平。SCHED\_FIFO一旦占用cpu则一直运行。一直运行直到有更高优先级任务到达或自己放弃。如果有相同优先级的实时进程（根据优先级计算的调度权值是一样的）已经准备好，FIFO时必须等待该进程主动放弃后才可以运行这个优先级相同的任务。而RR可以让每个任务都执行一段时间。
  
### 相同点：
    
RR和FIFO都只用于实时任务，创建时优先级大于0(1-99)，并按照可抢占优先级调度算法进行，就绪态的实时任务立即抢占非实时任务。

## 策略详细流程

### 所有任务都采用linux分时调度策略时：

1. 创建任务指定采用分时调度策略，并指定优先级nice值(-20~19)
2. 将根据每个任务的nice值确定在cpu上的执行时间(counter)
3. 如果没有等待资源，则将该任务加入到就绪队列中
4. 调度程序遍历就绪队列中的任务，通过对每个任务动态优先级的计算权值(counter+20-nice)结果，选择计算结果最大的一个去运行，当这个时间片用完后(counter减至0)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中
5. 此时调度程序重复上面计算过程，转到第4步
6. 当调度程序发现所有就绪任务计算所得的权值都为不大于0时，重复第2步
 
### 所有任务都采用FIFO时：

1. 创建进程时指定采用FIFO，并设置实时优先级rt\_priority(1-99)
2. 如果没有等待资源，则将该任务加入到就绪队列中
3. 调度程序遍历就绪队列，根据实时优先级计算调度权值(1000+rt\_priority),选择权值最高的任务使用cpu，该FIFO任务将一直占有cpu直到有优先级更高的任务就绪(即使优先级相同也不行)或者主动放弃(等待资源)
4. 调度程序发现有优先级更高的任务到达(高优先级任务可能被中断或定时器任务唤醒，再或被当前运行的任务唤醒，等等)，则调度程序立即在当前任务堆栈中保存当前cpu寄存器的所有数据，重新从高优先级任务的堆栈中加载寄存器数据到cpu，此时高优先级的任务开始运行。重复第3步
5. 如果当前任务因等待资源而主动放弃cpu使用权，则该任务将从就绪队列中删除，加入等待队列，此时重复第3步
 
### 所有任务都采用RR调度策略时：

1. 创建任务时指定调度参数为RR，并设置任务的实时优先级和nice值(nice值将会转换为该任务的时间片的长度)
2. 如果没有等待资源，则将该任务加入到就绪队列中
3. 调度程序遍历就绪队列，根据实时优先级计算调度权值(1000+rt\_priority),选择权值最高的任务使用cpu
4. 如果就绪队列中的RR任务时间片为0，则会根据nice值设置该任务的时间片，同时将该任务放入就绪队列的末尾。重复步骤3
5. 当前任务由于等待资源而主动退出cpu，则其加入等待队列中，重复步骤3

系统中既有分时调度，又有时间片轮转调度和先进先出调度，RR调度和FIFO调度的进程属于实时进程，以分时调度的进程是非实时进程。当实时进程准备就绪后，如果当前cpu正在运行非实时进程，则实时进程立即抢占非实时进程。RR进程和FIFO进程都采用实时优先级做为调度的权值标准，RR是FIFO的一个延伸。FIFO时，如果两个进程的优先级一样，则这两个优先级一样的进程具体执行哪一个是由其在队列中的未知决定的，这样导致一些不公正性(优先级是一样的，为什么要让你一直运行?),如果将两个优先级一样的任务的调度策略都设为RR,则保证了这两个任务可以循环执行，保证了公平

## Ingo Molnar-实时补丁

为了能并入主流内核，Ingo Molnar的实时补丁也采用了非常灵活的策略，它支持四种抢占模式：

1. No Forced Preemption (Server)，这种模式等同于没有使能抢占选项的标准内核，主要适用于科学计算等服务器环境
2. Voluntary Kernel Preemption (Desktop)，这种模式使能了自愿抢占，但仍然失效抢占内核选项，它通过增加抢占点缩减了抢占延迟，因此适用于一些需要较好的响应性的环境，如桌面环境，当然这种好的响应性是以牺牲一些吞吐率为代价的
3. Preemptible Kernel (Low-Latency Desktop)，这种模式既包含了自愿抢占，又使能了可抢占内核选项，因此有很好的响应延迟，实际上在一定程度上已经达到了软实时性。它主要适用于桌面和一些嵌入式系统，但是吞吐率比模式2更低
4. Complete Preemption (Real-Time)，这种模式使能了所有实时功能，因此完全能够满足软实时需求，它适用于延迟要求为100微秒或稍低的实时系统

实现实时是以牺牲系统的吞吐率为代价的，因此实时性越好，系统吞吐率就越低。